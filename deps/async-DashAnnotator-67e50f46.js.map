{"version":3,"file":"async-DashAnnotator-67e50f46.js","mappings":"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","sources":["webpack:///./node_modules/ramda/es/type.js","webpack:///./node_modules/ramda/es/unapply.js","webpack:///./node_modules/ramda/es/unary.js","webpack:///./node_modules/ramda/es/uncurryN.js","webpack:///./node_modules/ramda/es/unfold.js","webpack:///./node_modules/ramda/es/union.js","webpack:///./node_modules/ramda/es/unionWith.js","webpack:///./node_modules/ramda/es/uniq.js","webpack:///./node_modules/ramda/es/uniqBy.js","webpack:///./node_modules/ramda/es/uniqWith.js","webpack:///./node_modules/ramda/es/unless.js","webpack:///./node_modules/ramda/es/unnest.js","webpack:///./node_modules/ramda/es/until.js","webpack:///./node_modules/ramda/es/unwind.js","webpack:///./node_modules/ramda/es/update.js","webpack:///./node_modules/ramda/es/useWith.js","webpack:///./node_modules/ramda/es/values.js","webpack:///./node_modules/ramda/es/valuesIn.js","webpack:///./node_modules/ramda/es/view.js","webpack:///./node_modules/ramda/es/when.js","webpack:///./node_modules/ramda/es/where.js","webpack:///./node_modules/ramda/es/whereAny.js","webpack:///./node_modules/ramda/es/whereEq.js","webpack:///./node_modules/ramda/es/without.js","webpack:///./node_modules/ramda/es/xor.js","webpack:///./node_modules/ramda/es/xprod.js","webpack:///./node_modules/ramda/es/zip.js","webpack:///./node_modules/ramda/es/zipObj.js","webpack:///./node_modules/ramda/es/zipWith.js"],"sourcesContent":["import _curry1 from \"./internal/_curry1.js\";\n/**\n * Gives a single-word string description of the (native) type of a value,\n * returning such answers as 'Object', 'Number', 'Array', or 'Null'. Does not\n * attempt to distinguish user Object types any further, reporting them all as\n * 'Object'.\n *\n * @func\n * @memberOf R\n * @since v0.8.0\n * @category Type\n * @sig (* -> {*}) -> String\n * @param {*} val The value to test\n * @return {String}\n * @example\n *\n *      R.type({}); //=> \"Object\"\n *      R.type(1); //=> \"Number\"\n *      R.type(false); //=> \"Boolean\"\n *      R.type('s'); //=> \"String\"\n *      R.type(null); //=> \"Null\"\n *      R.type([]); //=> \"Array\"\n *      R.type(/[A-z]/); //=> \"RegExp\"\n *      R.type(() => {}); //=> \"Function\"\n *      R.type(undefined); //=> \"Undefined\"\n */\n\nvar type =\n/*#__PURE__*/\n_curry1(function type(val) {\n  return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);\n});\n\nexport default type;","import _curry1 from \"./internal/_curry1.js\";\n/**\n * Takes a function `fn`, which takes a single array argument, and returns a\n * function which:\n *\n *   - takes any number of positional arguments;\n *   - passes these arguments to `fn` as an array; and\n *   - returns the result.\n *\n * In other words, `R.unapply` derives a variadic function from a function which\n * takes an array. `R.unapply` is the inverse of [`R.apply`](#apply).\n *\n * @func\n * @memberOf R\n * @since v0.8.0\n * @category Function\n * @sig ([*...] -> a) -> (*... -> a)\n * @param {Function} fn\n * @return {Function}\n * @see R.apply\n * @example\n *\n *      R.unapply(JSON.stringify)(1, 2, 3); //=> '[1,2,3]'\n * @symb R.unapply(f)(a, b) = f([a, b])\n */\n\nvar unapply =\n/*#__PURE__*/\n_curry1(function unapply(fn) {\n  return function () {\n    return fn(Array.prototype.slice.call(arguments, 0));\n  };\n});\n\nexport default unapply;","import _curry1 from \"./internal/_curry1.js\";\nimport nAry from \"./nAry.js\";\n/**\n * Wraps a function of any arity (including nullary) in a function that accepts\n * exactly 1 parameter. Any extraneous parameters will not be passed to the\n * supplied function.\n *\n * @func\n * @memberOf R\n * @since v0.2.0\n * @category Function\n * @sig (a -> b -> c -> ... -> z) -> (a -> z)\n * @param {Function} fn The function to wrap.\n * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of\n *         arity 1.\n * @see R.binary, R.nAry\n * @example\n *\n *      const takesTwoArgs = function(a, b) {\n *        return [a, b];\n *      };\n *      takesTwoArgs.length; //=> 2\n *      takesTwoArgs(1, 2); //=> [1, 2]\n *\n *      const takesOneArg = R.unary(takesTwoArgs);\n *      takesOneArg.length; //=> 1\n *      // Only 1 argument is passed to the wrapped function\n *      takesOneArg(1, 2); //=> [1, undefined]\n * @symb R.unary(f)(a, b, c) = f(a)\n */\n\nvar unary =\n/*#__PURE__*/\n_curry1(function unary(fn) {\n  return nAry(1, fn);\n});\n\nexport default unary;","import _curry2 from \"./internal/_curry2.js\";\nimport curryN from \"./curryN.js\";\n/**\n * Returns a function of arity `n` from a (manually) curried function.\n * Note that, the returned function is actually a ramda style\n * curryied function, which can accept one or more arguments in each\n * function calling.\n *\n * @func\n * @memberOf R\n * @since v0.14.0\n * @category Function\n * @sig Number -> (a -> b -> c ... -> z) -> ((a -> b -> c ...) -> z)\n * @param {Number} length The arity for the returned function.\n * @param {Function} fn The function to uncurry.\n * @return {Function} A new function.\n * @see R.curry, R.curryN\n * @example\n *\n *      const addFour = a => b => c => d => a + b + c + d;\n *\n *      const uncurriedAddFour = R.uncurryN(4, addFour);\n *      uncurriedAddFour(1, 2, 3, 4); //=> 10\n */\n\nvar uncurryN =\n/*#__PURE__*/\n_curry2(function uncurryN(depth, fn) {\n  return curryN(depth, function () {\n    var currentDepth = 1;\n    var value = fn;\n    var idx = 0;\n    var endIdx;\n\n    while (currentDepth <= depth && typeof value === 'function') {\n      endIdx = currentDepth === depth ? arguments.length : idx + value.length;\n      value = value.apply(this, Array.prototype.slice.call(arguments, idx, endIdx));\n      currentDepth += 1;\n      idx = endIdx;\n    }\n\n    return value;\n  });\n});\n\nexport default uncurryN;","import _curry2 from \"./internal/_curry2.js\";\n/**\n * Builds a list from a seed value. Accepts an iterator function, which returns\n * either false to stop iteration or an array of length 2 containing the value\n * to add to the resulting list and the seed to be used in the next call to the\n * iterator function.\n *\n * The iterator function receives one argument: *(seed)*.\n *\n * @func\n * @memberOf R\n * @since v0.10.0\n * @category List\n * @sig (a -> [b]) -> * -> [b]\n * @param {Function} fn The iterator function. receives one argument, `seed`, and returns\n *        either false to quit iteration or an array of length two to proceed. The element\n *        at index 0 of this array will be added to the resulting array, and the element\n *        at index 1 will be passed to the next call to `fn`.\n * @param {*} seed The seed value.\n * @return {Array} The final list.\n * @example\n *\n *      const f = n => n > 50 ? false : [-n, n + 10];\n *      R.unfold(f, 10); //=> [-10, -20, -30, -40, -50]\n * @symb R.unfold(f, x) = [f(x)[0], f(f(x)[1])[0], f(f(f(x)[1])[1])[0], ...]\n */\n\nvar unfold =\n/*#__PURE__*/\n_curry2(function unfold(fn, seed) {\n  var pair = fn(seed);\n  var result = [];\n\n  while (pair && pair.length) {\n    result[result.length] = pair[0];\n    pair = fn(pair[1]);\n  }\n\n  return result;\n});\n\nexport default unfold;","import _concat from \"./internal/_concat.js\";\nimport _curry2 from \"./internal/_curry2.js\";\nimport compose from \"./compose.js\";\nimport uniq from \"./uniq.js\";\n/**\n * Combines two lists into a set (i.e. no duplicates) composed of the elements\n * of each list.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category Relation\n * @sig [*] -> [*] -> [*]\n * @param {Array} as The first list.\n * @param {Array} bs The second list.\n * @return {Array} The first and second lists concatenated, with\n *         duplicates removed.\n * @example\n *\n *      R.union([1, 2, 3], [2, 3, 4]); //=> [1, 2, 3, 4]\n */\n\nvar union =\n/*#__PURE__*/\n_curry2(\n/*#__PURE__*/\ncompose(uniq, _concat));\n\nexport default union;","import _concat from \"./internal/_concat.js\";\nimport _curry3 from \"./internal/_curry3.js\";\nimport uniqWith from \"./uniqWith.js\";\n/**\n * Combines two lists into a set (i.e. no duplicates) composed of the elements\n * of each list. Duplication is determined according to the value returned by\n * applying the supplied predicate to two list elements. If an element exists\n * in both lists, the first element from the first list will be used.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category Relation\n * @sig ((a, a) -> Boolean) -> [*] -> [*] -> [*]\n * @param {Function} pred A predicate used to test whether two items are equal.\n * @param {Array} list1 The first list.\n * @param {Array} list2 The second list.\n * @return {Array} The first and second lists concatenated, with\n *         duplicates removed.\n * @see R.union\n * @example\n *\n *      const l1 = [{a: 1}, {a: 2}];\n *      const l2 = [{a: 1}, {a: 4}];\n *      R.unionWith(R.eqBy(R.prop('a')), l1, l2); //=> [{a: 1}, {a: 2}, {a: 4}]\n */\n\nvar unionWith =\n/*#__PURE__*/\n_curry3(function unionWith(pred, list1, list2) {\n  return uniqWith(pred, _concat(list1, list2));\n});\n\nexport default unionWith;","import identity from \"./identity.js\";\nimport uniqBy from \"./uniqBy.js\";\n/**\n * Returns a new list containing only one copy of each element in the original\n * list. [`R.equals`](#equals) is used to determine equality.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category List\n * @sig [a] -> [a]\n * @param {Array} list The array to consider.\n * @return {Array} The list of unique items.\n * @example\n *\n *      R.uniq([1, 1, 2, 1]); //=> [1, 2]\n *      R.uniq([1, '1']);     //=> [1, '1']\n *      R.uniq([[42], [42]]); //=> [[42]]\n */\n\nvar uniq =\n/*#__PURE__*/\nuniqBy(identity);\nexport default uniq;","import _Set from \"./internal/_Set.js\";\nimport _curry2 from \"./internal/_curry2.js\";\nimport _dispatchable from \"./internal/_dispatchable.js\";\nimport _xuniqBy from \"./internal/_xuniqBy.js\";\n/**\n * Returns a new list containing only one copy of each element in the original\n * list, based upon the value returned by applying the supplied function to\n * each list element. Prefers the first item if the supplied function produces\n * the same value on two items. [`R.equals`](#equals) is used for comparison.\n *\n * Acts as a transducer if a transformer is given in list position.\n *\n * @func\n * @memberOf R\n * @since v0.16.0\n * @category List\n * @sig (a -> b) -> [a] -> [a]\n * @param {Function} fn A function used to produce a value to use during comparisons.\n * @param {Array} list The array to consider.\n * @return {Array} The list of unique items.\n * @example\n *\n *      R.uniqBy(Math.abs, [-1, -5, 2, 10, 1, 2]); //=> [-1, -5, 2, 10]\n */\n\nvar uniqBy =\n/*#__PURE__*/\n_curry2(\n/*#__PURE__*/\n_dispatchable([], _xuniqBy, function (fn, list) {\n  var set = new _Set();\n  var result = [];\n  var idx = 0;\n  var appliedItem, item;\n\n  while (idx < list.length) {\n    item = list[idx];\n    appliedItem = fn(item);\n\n    if (set.add(appliedItem)) {\n      result.push(item);\n    }\n\n    idx += 1;\n  }\n\n  return result;\n}));\n\nexport default uniqBy;","import _curry2 from \"./internal/_curry2.js\";\nimport _dispatchable from \"./internal/_dispatchable.js\";\nimport _includesWith from \"./internal/_includesWith.js\";\nimport _xuniqWith from \"./internal/_xuniqWith.js\";\n/**\n * Returns a new list containing only one copy of each element in the original\n * list, based upon the value returned by applying the supplied predicate to\n * two list elements. Prefers the first item if two items compare equal based\n * on the predicate.\n *\n * Acts as a transducer if a transformer is given in list position.\n *\n * @func\n * @memberOf R\n * @since v0.2.0\n * @category List\n * @sig ((a, a) -> Boolean) -> [a] -> [a]\n * @param {Function} pred A predicate used to test whether two items are equal.\n * @param {Array} list The array to consider.\n * @return {Array} The list of unique items.\n * @example\n *\n *      const strEq = R.eqBy(String);\n *      R.uniqWith(strEq)([1, '1', 2, 1]); //=> [1, 2]\n *      R.uniqWith(strEq)([{}, {}]);       //=> [{}]\n *      R.uniqWith(strEq)([1, '1', 1]);    //=> [1]\n *      R.uniqWith(strEq)(['1', 1, 1]);    //=> ['1']\n */\n\nvar uniqWith =\n/*#__PURE__*/\n_curry2(\n/*#__PURE__*/\n_dispatchable([], _xuniqWith, function (pred, list) {\n  var idx = 0;\n  var len = list.length;\n  var result = [];\n  var item;\n\n  while (idx < len) {\n    item = list[idx];\n\n    if (!_includesWith(pred, item, result)) {\n      result[result.length] = item;\n    }\n\n    idx += 1;\n  }\n\n  return result;\n}));\n\nexport default uniqWith;","import _curry3 from \"./internal/_curry3.js\";\n/**\n * Tests the final argument by passing it to the given predicate function. If\n * the predicate is not satisfied, the function will return the result of\n * calling the `whenFalseFn` function with the same argument. If the predicate\n * is satisfied, the argument is returned as is.\n *\n * @func\n * @memberOf R\n * @since v0.18.0\n * @category Logic\n * @sig (a -> Boolean) -> (a -> b) -> a -> a | b\n * @param {Function} pred        A predicate function\n * @param {Function} whenFalseFn A function to invoke when the `pred` evaluates\n *                               to a falsy value.\n * @param {*}        x           An object to test with the `pred` function and\n *                               pass to `whenFalseFn` if necessary.\n * @return {*} Either `x` or the result of applying `x` to `whenFalseFn`.\n * @see R.ifElse, R.when, R.cond\n * @example\n *\n *      let safeInc = R.unless(R.isNil, R.inc);\n *      safeInc(null); //=> null\n *      safeInc(1); //=> 2\n */\n\nvar unless =\n/*#__PURE__*/\n_curry3(function unless(pred, whenFalseFn, x) {\n  return pred(x) ? x : whenFalseFn(x);\n});\n\nexport default unless;","import _identity from \"./internal/_identity.js\";\nimport chain from \"./chain.js\";\n/**\n * Shorthand for `R.chain(R.identity)`, which removes one level of nesting from\n * any [Chain](https://github.com/fantasyland/fantasy-land#chain).\n *\n * @func\n * @memberOf R\n * @since v0.3.0\n * @category List\n * @sig Chain c => c (c a) -> c a\n * @param {*} list\n * @return {*}\n * @see R.flatten, R.chain\n * @example\n *\n *      R.unnest([1, [2], [[3]]]); //=> [1, 2, [3]]\n *      R.unnest([[1, 2], [3, 4], [5, 6]]); //=> [1, 2, 3, 4, 5, 6]\n */\n\nvar unnest =\n/*#__PURE__*/\nchain(_identity);\nexport default unnest;","import _curry3 from \"./internal/_curry3.js\";\n/**\n * Takes a predicate, a transformation function, and an initial value,\n * and returns a value of the same type as the initial value.\n * It does so by applying the transformation until the predicate is satisfied,\n * at which point it returns the satisfactory value.\n *\n * @func\n * @memberOf R\n * @since v0.20.0\n * @category Logic\n * @sig (a -> Boolean) -> (a -> a) -> a -> a\n * @param {Function} pred A predicate function\n * @param {Function} fn The iterator function\n * @param {*} init Initial value\n * @return {*} Final value that satisfies predicate\n * @example\n *\n *      R.until(R.gt(R.__, 100), R.multiply(2))(1) // => 128\n */\n\nvar until =\n/*#__PURE__*/\n_curry3(function until(pred, fn, init) {\n  var val = init;\n\n  while (!pred(val)) {\n    val = fn(val);\n  }\n\n  return val;\n});\n\nexport default until;","import _curry2 from \"./internal/_curry2.js\";\nimport _isArray from \"./internal/_isArray.js\";\nimport _map from \"./internal/_map.js\";\nimport _assoc from \"./internal/_assoc.js\";\n/**\n *\n * Deconstructs an array field from the input documents to output a document for each element.\n * Each output document is the input document with the value of the array field replaced by the element.\n *\n * @func\n * @memberOf R\n * @since v0.28.0\n * @category Object\n * @sig String -> {k: [v]} -> [{k: v}]\n * @param {String} key The key to determine which property of the object should be unwind\n * @param {Object} object The object containing list under property named as key which is to unwind\n * @return {List} A new list of object containing the value of input key having list replaced by each element in the object.\n * @example\n *\n * R.unwind('hobbies', {\n *   name: 'alice',\n *   hobbies: ['Golf', 'Hacking'],\n *   colors: ['red', 'green'],\n * });\n * // [\n * //   { name: 'alice', hobbies: 'Golf', colors: ['red', 'green'] },\n * //   { name: 'alice', hobbies: 'Hacking', colors: ['red', 'green'] }\n * // ]\n */\n\nvar unwind =\n/*#__PURE__*/\n_curry2(function (key, object) {\n  // If key is not in object or key is not as a list in object\n  if (!(key in object && _isArray(object[key]))) {\n    return [object];\n  } // Map over object[key] which is a list and assoc each element with key\n\n\n  return _map(function (item) {\n    return _assoc(key, item, object);\n  }, object[key]);\n});\n\nexport default unwind;","import _curry3 from \"./internal/_curry3.js\";\nimport adjust from \"./adjust.js\";\nimport always from \"./always.js\";\n/**\n * Returns a new copy of the array with the element at the provided index\n * replaced with the given value.\n *\n * @func\n * @memberOf R\n * @since v0.14.0\n * @category List\n * @sig Number -> a -> [a] -> [a]\n * @param {Number} idx The index to update.\n * @param {*} x The value to exist at the given index of the returned array.\n * @param {Array|Arguments} list The source array-like object to be updated.\n * @return {Array} A copy of `list` with the value at index `idx` replaced with `x`.\n * @see R.adjust\n * @example\n *\n *      R.update(1, '_', ['a', 'b', 'c']);      //=> ['a', '_', 'c']\n *      R.update(-1, '_', ['a', 'b', 'c']);     //=> ['a', 'b', '_']\n * @symb R.update(-1, a, [b, c]) = [b, a]\n * @symb R.update(0, a, [b, c]) = [a, c]\n * @symb R.update(1, a, [b, c]) = [b, a]\n */\n\nvar update =\n/*#__PURE__*/\n_curry3(function update(idx, x, list) {\n  return adjust(idx, always(x), list);\n});\n\nexport default update;","import _curry2 from \"./internal/_curry2.js\";\nimport curryN from \"./curryN.js\";\n/**\n * Accepts a function `fn` and a list of transformer functions and returns a\n * new curried function. When the new function is invoked, it calls the\n * function `fn` with parameters consisting of the result of calling each\n * supplied handler on successive arguments to the new function.\n *\n * If more arguments are passed to the returned function than transformer\n * functions, those arguments are passed directly to `fn` as additional\n * parameters. If you expect additional arguments that don't need to be\n * transformed, although you can ignore them, it's best to pass an identity\n * function so that the new function reports the correct arity.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category Function\n * @sig ((x1, x2, ...) -> z) -> [(a -> x1), (b -> x2), ...] -> (a -> b -> ... -> z)\n * @param {Function} fn The function to wrap.\n * @param {Array} transformers A list of transformer functions\n * @return {Function} The wrapped function.\n * @see R.converge\n * @example\n *\n *      R.useWith(Math.pow, [R.identity, R.identity])(3, 4); //=> 81\n *      R.useWith(Math.pow, [R.identity, R.identity])(3)(4); //=> 81\n *      R.useWith(Math.pow, [R.dec, R.inc])(3, 4); //=> 32\n *      R.useWith(Math.pow, [R.dec, R.inc])(3)(4); //=> 32\n * @symb R.useWith(f, [g, h])(a, b) = f(g(a), h(b))\n */\n\nvar useWith =\n/*#__PURE__*/\n_curry2(function useWith(fn, transformers) {\n  return curryN(transformers.length, function () {\n    var args = [];\n    var idx = 0;\n\n    while (idx < transformers.length) {\n      args.push(transformers[idx].call(this, arguments[idx]));\n      idx += 1;\n    }\n\n    return fn.apply(this, args.concat(Array.prototype.slice.call(arguments, transformers.length)));\n  });\n});\n\nexport default useWith;","import _curry1 from \"./internal/_curry1.js\";\nimport keys from \"./keys.js\";\n/**\n * Returns a list of all the enumerable own properties of the supplied object.\n * Note that the order of the output array is not guaranteed across different\n * JS platforms.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category Object\n * @sig {k: v} -> [v]\n * @param {Object} obj The object to extract values from\n * @return {Array} An array of the values of the object's own properties.\n * @see R.valuesIn, R.keys, R.toPairs\n * @example\n *\n *      R.values({a: 1, b: 2, c: 3}); //=> [1, 2, 3]\n */\n\nvar values =\n/*#__PURE__*/\n_curry1(function values(obj) {\n  var props = keys(obj);\n  var len = props.length;\n  var vals = [];\n  var idx = 0;\n\n  while (idx < len) {\n    vals[idx] = obj[props[idx]];\n    idx += 1;\n  }\n\n  return vals;\n});\n\nexport default values;","import _curry1 from \"./internal/_curry1.js\";\n/**\n * Returns a list of all the properties, including prototype properties, of the\n * supplied object.\n * Note that the order of the output array is not guaranteed to be consistent\n * across different JS platforms.\n *\n * @func\n * @memberOf R\n * @since v0.2.0\n * @category Object\n * @sig {k: v} -> [v]\n * @param {Object} obj The object to extract values from\n * @return {Array} An array of the values of the object's own and prototype properties.\n * @see R.values, R.keysIn\n * @example\n *\n *      const F = function() { this.x = 'X'; };\n *      F.prototype.y = 'Y';\n *      const f = new F();\n *      R.valuesIn(f); //=> ['X', 'Y']\n */\n\nvar valuesIn =\n/*#__PURE__*/\n_curry1(function valuesIn(obj) {\n  var prop;\n  var vs = [];\n\n  for (prop in obj) {\n    vs[vs.length] = obj[prop];\n  }\n\n  return vs;\n});\n\nexport default valuesIn;","import _curry2 from \"./internal/_curry2.js\"; // `Const` is a functor that effectively ignores the function given to `map`.\n\nvar Const = function (x) {\n  return {\n    value: x,\n    'fantasy-land/map': function () {\n      return this;\n    }\n  };\n};\n/**\n * Returns a \"view\" of the given data structure, determined by the given lens.\n * The lens's focus determines which portion of the data structure is visible.\n *\n * @func\n * @memberOf R\n * @since v0.16.0\n * @category Object\n * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s\n * @sig Lens s a -> s -> a\n * @param {Lens} lens\n * @param {*} x\n * @return {*}\n * @see R.set, R.over, R.lens, R.lensIndex, R.lensProp, R.lensPath\n * @example\n *\n *      const xLens = R.lensProp('x');\n *\n *      R.view(xLens, {x: 1, y: 2});  //=> 1\n *      R.view(xLens, {x: 4, y: 2});  //=> 4\n */\n\n\nvar view =\n/*#__PURE__*/\n_curry2(function view(lens, x) {\n  // Using `Const` effectively ignores the setter function of the `lens`,\n  // leaving the value returned by the getter function unmodified.\n  return lens(Const)(x).value;\n});\n\nexport default view;","import _curry3 from \"./internal/_curry3.js\";\n/**\n * Tests the final argument by passing it to the given predicate function. If\n * the predicate is satisfied, the function will return the result of calling\n * the `whenTrueFn` function with the same argument. If the predicate is not\n * satisfied, the argument is returned as is.\n *\n * @func\n * @memberOf R\n * @since v0.18.0\n * @category Logic\n * @sig (a -> Boolean) -> (a -> b) -> a -> a | b\n * @param {Function} pred       A predicate function\n * @param {Function} whenTrueFn A function to invoke when the `condition`\n *                              evaluates to a truthy value.\n * @param {*}        x          An object to test with the `pred` function and\n *                              pass to `whenTrueFn` if necessary.\n * @return {*} Either `x` or the result of applying `x` to `whenTrueFn`.\n * @see R.ifElse, R.unless, R.cond\n * @example\n *\n *      // truncate :: String -> String\n *      const truncate = R.when(\n *        R.propSatisfies(R.gt(R.__, 10), 'length'),\n *        R.pipe(R.take(10), R.append('…'), R.join(''))\n *      );\n *      truncate('12345');         //=> '12345'\n *      truncate('0123456789ABC'); //=> '0123456789…'\n */\n\nvar when =\n/*#__PURE__*/\n_curry3(function when(pred, whenTrueFn, x) {\n  return pred(x) ? whenTrueFn(x) : x;\n});\n\nexport default when;","import _curry2 from \"./internal/_curry2.js\";\nimport _has from \"./internal/_has.js\";\n/**\n * Takes a spec object and a test object; returns true if the test satisfies\n * the spec. Each of the spec's own properties must be a predicate function.\n * Each predicate is applied to the value of the corresponding property of the\n * test object. `where` returns true if all the predicates return true, false\n * otherwise.\n *\n * `where` is well suited to declaratively expressing constraints for other\n * functions such as [`filter`](#filter) and [`find`](#find).\n *\n * @func\n * @memberOf R\n * @since v0.1.1\n * @category Object\n * @sig {String: (* -> Boolean)} -> {String: *} -> Boolean\n * @param {Object} spec\n * @param {Object} testObj\n * @return {Boolean}\n * @see R.propSatisfies, R.whereEq\n * @example\n *\n *      // pred :: Object -> Boolean\n *      const pred = R.where({\n *        a: R.equals('foo'),\n *        b: R.complement(R.equals('bar')),\n *        x: R.gt(R.__, 10),\n *        y: R.lt(R.__, 20)\n *      });\n *\n *      pred({a: 'foo', b: 'xxx', x: 11, y: 19}); //=> true\n *      pred({a: 'xxx', b: 'xxx', x: 11, y: 19}); //=> false\n *      pred({a: 'foo', b: 'bar', x: 11, y: 19}); //=> false\n *      pred({a: 'foo', b: 'xxx', x: 10, y: 19}); //=> false\n *      pred({a: 'foo', b: 'xxx', x: 11, y: 20}); //=> false\n */\n\nvar where =\n/*#__PURE__*/\n_curry2(function where(spec, testObj) {\n  for (var prop in spec) {\n    if (_has(prop, spec) && !spec[prop](testObj[prop])) {\n      return false;\n    }\n  }\n\n  return true;\n});\n\nexport default where;","import _curry2 from \"./internal/_curry2.js\";\nimport _has from \"./internal/_has.js\";\n/**\n * Takes a spec object and a test object; each of the spec's own properties must be a predicate function.\n * Each predicate is applied to the value of the corresponding property of the\n * test object. `whereAny` returns true if at least one of the predicates return true,\n * false otherwise.\n *\n * `whereAny` is well suited to declaratively expressing constraints for other\n * functions such as [`filter`](#filter) and [`find`](#find).\n *\n * @func\n * @memberOf R\n * @since v0.28.0\n * @category Object\n * @sig {String: (* -> Boolean)} -> {String: *} -> Boolean\n * @param {Object} spec\n * @param {Object} testObj\n * @return {Boolean}\n * @see R.propSatisfies, R.where\n * @example\n *\n *      // pred :: Object -> Boolean\n *      const pred = R.whereAny({\n *        a: R.equals('foo'),\n *        b: R.complement(R.equals('xxx')),\n *        x: R.gt(R.__, 10),\n *        y: R.lt(R.__, 20)\n *      });\n *\n *      pred({a: 'foo', b: 'xxx', x: 8, y: 34}); //=> true\n *      pred({a: 'xxx', b: 'xxx', x: 9, y: 21}); //=> false\n *      pred({a: 'bar', b: 'xxx', x: 10, y: 20}); //=> false\n *      pred({a: 'foo', b: 'bar', x: 10, y: 20}); //=> true\n *      pred({a: 'foo', b: 'xxx', x: 11, y: 20}); //=> true\n */\n\nvar whereAny =\n/*#__PURE__*/\n_curry2(function whereAny(spec, testObj) {\n  for (var prop in spec) {\n    if (_has(prop, spec) && spec[prop](testObj[prop])) {\n      return true;\n    }\n  }\n\n  return false;\n});\n\nexport default whereAny;","import _curry2 from \"./internal/_curry2.js\";\nimport equals from \"./equals.js\";\nimport map from \"./map.js\";\nimport where from \"./where.js\";\n/**\n * Takes a spec object and a test object; returns true if the test satisfies\n * the spec, false otherwise. An object satisfies the spec if, for each of the\n * spec's own properties, accessing that property of the object gives the same\n * value (in [`R.equals`](#equals) terms) as accessing that property of the\n * spec.\n *\n * `whereEq` is a specialization of [`where`](#where).\n *\n * @func\n * @memberOf R\n * @since v0.14.0\n * @category Object\n * @sig {String: *} -> {String: *} -> Boolean\n * @param {Object} spec\n * @param {Object} testObj\n * @return {Boolean}\n * @see R.propEq, R.where\n * @example\n *\n *      // pred :: Object -> Boolean\n *      const pred = R.whereEq({a: 1, b: 2});\n *\n *      pred({a: 1});              //=> false\n *      pred({a: 1, b: 2});        //=> true\n *      pred({a: 1, b: 2, c: 3});  //=> true\n *      pred({a: 1, b: 1});        //=> false\n */\n\nvar whereEq =\n/*#__PURE__*/\n_curry2(function whereEq(spec, testObj) {\n  return where(map(equals, spec), testObj);\n});\n\nexport default whereEq;","import _includes from \"./internal/_includes.js\";\nimport _curry2 from \"./internal/_curry2.js\";\nimport flip from \"./flip.js\";\nimport reject from \"./reject.js\";\n/**\n * Returns a new list without values in the first argument.\n * [`R.equals`](#equals) is used to determine equality.\n *\n * Acts as a transducer if a transformer is given in list position.\n *\n * @func\n * @memberOf R\n * @since v0.19.0\n * @category List\n * @sig [a] -> [a] -> [a]\n * @param {Array} list1 The values to be removed from `list2`.\n * @param {Array} list2 The array to remove values from.\n * @return {Array} The new array without values in `list1`.\n * @see R.transduce, R.difference, R.remove\n * @example\n *\n *      R.without([1, 2], [1, 2, 1, 3, 4]); //=> [3, 4]\n */\n\nvar without =\n/*#__PURE__*/\n_curry2(function (xs, list) {\n  return reject(flip(_includes)(xs), list);\n});\n\nexport default without;","import _curry2 from \"./internal/_curry2.js\";\n/**\n * Exclusive disjunction logical operation.\n * Returns `true` if one of the arguments is truthy and the other is falsy.\n * Otherwise, it returns `false`.\n *\n * @func\n * @memberOf R\n * @since v0.27.1\n * @category Logic\n * @sig a -> b -> Boolean\n * @param {Any} a\n * @param {Any} b\n * @return {Boolean} true if one of the arguments is truthy and the other is falsy\n * @see R.or, R.and\n * @example\n *\n *      R.xor(true, true); //=> false\n *      R.xor(true, false); //=> true\n *      R.xor(false, true); //=> true\n *      R.xor(false, false); //=> false\n */\n\nvar xor =\n/*#__PURE__*/\n_curry2(function xor(a, b) {\n  return Boolean(!a ^ !b);\n});\n\nexport default xor;","import _curry2 from \"./internal/_curry2.js\";\n/**\n * Creates a new list out of the two supplied by creating each possible pair\n * from the lists.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category List\n * @sig [a] -> [b] -> [[a,b]]\n * @param {Array} as The first list.\n * @param {Array} bs The second list.\n * @return {Array} The list made by combining each possible pair from\n *         `as` and `bs` into pairs (`[a, b]`).\n * @example\n *\n *      R.xprod([1, 2], ['a', 'b']); //=> [[1, 'a'], [1, 'b'], [2, 'a'], [2, 'b']]\n * @symb R.xprod([a, b], [c, d]) = [[a, c], [a, d], [b, c], [b, d]]\n */\n\nvar xprod =\n/*#__PURE__*/\n_curry2(function xprod(a, b) {\n  // = xprodWith(prepend); (takes about 3 times as long...)\n  var idx = 0;\n  var ilen = a.length;\n  var j;\n  var jlen = b.length;\n  var result = [];\n\n  while (idx < ilen) {\n    j = 0;\n\n    while (j < jlen) {\n      result[result.length] = [a[idx], b[j]];\n      j += 1;\n    }\n\n    idx += 1;\n  }\n\n  return result;\n});\n\nexport default xprod;","import _curry2 from \"./internal/_curry2.js\";\n/**\n * Creates a new list out of the two supplied by pairing up equally-positioned\n * items from both lists. The returned list is truncated to the length of the\n * shorter of the two input lists.\n * Note: `zip` is equivalent to `zipWith(function(a, b) { return [a, b] })`.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category List\n * @sig [a] -> [b] -> [[a,b]]\n * @param {Array} list1 The first array to consider.\n * @param {Array} list2 The second array to consider.\n * @return {Array} The list made by pairing up same-indexed elements of `list1` and `list2`.\n * @example\n *\n *      R.zip([1, 2, 3], ['a', 'b', 'c']); //=> [[1, 'a'], [2, 'b'], [3, 'c']]\n * @symb R.zip([a, b, c], [d, e, f]) = [[a, d], [b, e], [c, f]]\n */\n\nvar zip =\n/*#__PURE__*/\n_curry2(function zip(a, b) {\n  var rv = [];\n  var idx = 0;\n  var len = Math.min(a.length, b.length);\n\n  while (idx < len) {\n    rv[idx] = [a[idx], b[idx]];\n    idx += 1;\n  }\n\n  return rv;\n});\n\nexport default zip;","import _curry2 from \"./internal/_curry2.js\";\n/**\n * Creates a new object out of a list of keys and a list of values.\n * Key/value pairing is truncated to the length of the shorter of the two lists.\n * Note: `zipObj` is equivalent to `pipe(zip, fromPairs)`.\n *\n * @func\n * @memberOf R\n * @since v0.3.0\n * @category List\n * @sig [String] -> [*] -> {String: *}\n * @param {Array} keys The array that will be properties on the output object.\n * @param {Array} values The list of values on the output object.\n * @return {Object} The object made by pairing up same-indexed elements of `keys` and `values`.\n * @example\n *\n *      R.zipObj(['a', 'b', 'c'], [1, 2, 3]); //=> {a: 1, b: 2, c: 3}\n */\n\nvar zipObj =\n/*#__PURE__*/\n_curry2(function zipObj(keys, values) {\n  var idx = 0;\n  var len = Math.min(keys.length, values.length);\n  var out = {};\n\n  while (idx < len) {\n    out[keys[idx]] = values[idx];\n    idx += 1;\n  }\n\n  return out;\n});\n\nexport default zipObj;","import _curry3 from \"./internal/_curry3.js\";\n/**\n * Creates a new list out of the two supplied by applying the function to each\n * equally-positioned pair in the lists. The returned list is truncated to the\n * length of the shorter of the two input lists.\n *\n * @function\n * @memberOf R\n * @since v0.1.0\n * @category List\n * @sig ((a, b) -> c) -> [a] -> [b] -> [c]\n * @param {Function} fn The function used to combine the two elements into one value.\n * @param {Array} list1 The first array to consider.\n * @param {Array} list2 The second array to consider.\n * @return {Array} The list made by combining same-indexed elements of `list1` and `list2`\n *         using `fn`.\n * @example\n *\n *      const f = (x, y) => {\n *        // ...\n *      };\n *      R.zipWith(f, [1, 2, 3], ['a', 'b', 'c']);\n *      //=> [f(1, 'a'), f(2, 'b'), f(3, 'c')]\n * @symb R.zipWith(fn, [a, b, c], [d, e, f]) = [fn(a, d), fn(b, e), fn(c, f)]\n */\n\nvar zipWith =\n/*#__PURE__*/\n_curry3(function zipWith(fn, a, b) {\n  var rv = [];\n  var idx = 0;\n  var len = Math.min(a.length, b.length);\n\n  while (idx < len) {\n    rv[idx] = fn(a[idx], b[idx]);\n    idx += 1;\n  }\n\n  return rv;\n});\n\nexport default zipWith;"],"names":["val","undefined","Object","prototype","toString","call","slice","fn","Array","arguments","depth","endIdx","currentDepth","value","idx","length","apply","this","seed","pair","result","pred","list1","list2","list","appliedItem","item","set","add","push","len","whenFalseFn","x","init","key","object","transformers","args","concat","obj","props","vals","prop","vs","Const","lens","whenTrueFn","spec","testObj","xs","a","b","Boolean","j","ilen","jlen","rv","Math","min","keys","values","out"],"sourceRoot":""}